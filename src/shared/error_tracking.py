"""
Error tracking and alerting system for federated learning.
Provides centralized error handling, tracking, and notification capabilities.
"""

import traceback
import threading
import time
from datetime import datetime, timedelta
from typing import Dict, List, Any, Optional, Callable
from dataclasses import dataclass, field
from collections import defaultdict, deque
from enum import Enum
import logging
import json

logger = logging.getLogger(__name__)


class ErrorSeverity(Enum):
    """Error severity levels."""
    LOW = "low"
    MEDIUM = "medium"
    HIGH = "high"
    CRITICAL = "critical"


class ErrorCategory(Enum):
    """Error categories for classification."""
    NETWORK = "network"
    COMPUTATION = "computation"
    PRIVACY = "privacy"
    VALIDATION = "validation"
    AGGREGATION = "aggregation"
    STORAGE = "storage"
    CONFIGURATION = "configuration"
    AUTHENTICATION = "authentication"
    SYSTEM = "system"
    UNKNOWN = "unknown"


@dataclass
class ErrorEvent:
    """Represents an error event in the system."""
    error_id: str
    timestamp: datetime
    component: str
    category: ErrorCategory
    severity: ErrorSeverity
    message: str
    exception_type: str
    stack_trace: str
    context: Dict[str, Any] = field(default_factory=dict)
    client_id: Optional[str] = None
    round_number: Optional[int] = None
    resolved: bool = False
    resolved_at: Optional[datetime] = None
    resolution_notes: Optional[str] = None
    occurrence_count: int = 1


@dataclass
class ErrorPattern:
    """Represents a pattern of recurring errors."""
    pattern_id: str
    error_signature: str
    category: ErrorCategory
    first_occurrence: datetime
    last_occurrence: datetime
    occurrence_count: int
    affected_components: List[str]
    affected_clients: List[str]
    severity: ErrorSeverity
    description: str


class ErrorTracker:
    """Tracks and analyzes errors in the federated learning system."""
    
    def __init__(self, max_errors: int = 10000, pattern_detection_window: int = 3600):
        """
        Initialize error tracker.
        
        Args:
            max_errors: Maximum number of errors to keep in memory
            pattern_detection_window: Time window in seconds for pattern detection
        """
        self.max_errors = max_errors
        self.pattern_detection_window = pattern_detection_window
        
        # Error storage
        self.errors: deque = deque(maxlen=max_errors)
        self.error_patterns: Dict[str, ErrorPattern] = {}
        
        # Error callbacks
        self.error_callbacks: List[Callable[[ErrorEvent], None]] = []
        self.pattern_callbacks: List[Callable[[ErrorPattern], None]] = []
        
        # Thread safety
        self.lock = threading.RLock()
        
        # Statistics
        self.error_stats = defaultdict(int)\n        \n        logger.info(f\"ErrorTracker initialized with max_errors={max_errors}\")\n    \n    def track_error(\n        self,\n        component: str,\n        exception: Exception,\n        category: ErrorCategory = ErrorCategory.UNKNOWN,\n        severity: ErrorSeverity = ErrorSeverity.MEDIUM,\n        context: Optional[Dict[str, Any]] = None,\n        client_id: Optional[str] = None,\n        round_number: Optional[int] = None\n    ) -> str:\n        \"\"\"\n        Track an error event.\n        \n        Args:\n            component: Component where error occurred\n            exception: The exception that occurred\n            category: Error category\n            severity: Error severity\n            context: Additional context information\n            client_id: Client ID if applicable\n            round_number: Round number if applicable\n            \n        Returns:\n            Error ID for tracking\n        \"\"\"\n        error_id = f\"{component}_{int(time.time())}_{id(exception)}\"\n        \n        error_event = ErrorEvent(\n            error_id=error_id,\n            timestamp=datetime.now(),\n            component=component,\n            category=category,\n            severity=severity,\n            message=str(exception),\n            exception_type=type(exception).__name__,\n            stack_trace=traceback.format_exc(),\n            context=context or {},\n            client_id=client_id,\n            round_number=round_number\n        )\n        \n        with self.lock:\n            # Check for duplicate errors\n            existing_error = self._find_duplicate_error(error_event)\n            if existing_error:\n                existing_error.occurrence_count += 1\n                existing_error.timestamp = datetime.now()\n                logger.debug(f\"Incremented occurrence count for error {existing_error.error_id}\")\n            else:\n                self.errors.append(error_event)\n                logger.error(f\"New error tracked: {error_id} - {error_event.message}\")\n            \n            # Update statistics\n            self.error_stats[f\"{component}_{category.value}\"] += 1\n            self.error_stats[f\"severity_{severity.value}\"] += 1\n            \n            # Detect patterns\n            self._detect_error_patterns(error_event)\n        \n        # Notify callbacks\n        for callback in self.error_callbacks:\n            try:\n                callback(error_event)\n            except Exception as e:\n                logger.error(f\"Error callback failed: {str(e)}\")\n        \n        return error_id\n    \n    def _find_duplicate_error(self, new_error: ErrorEvent) -> Optional[ErrorEvent]:\n        \"\"\"Find if this error is a duplicate of an existing error.\"\"\"\n        # Look for errors with same signature in recent history\n        cutoff_time = datetime.now() - timedelta(minutes=5)\n        \n        for error in reversed(self.errors):\n            if error.timestamp < cutoff_time:\n                break\n            \n            if (\n                error.component == new_error.component and\n                error.exception_type == new_error.exception_type and\n                error.message == new_error.message and\n                error.client_id == new_error.client_id\n            ):\n                return error\n        \n        return None\n    \n    def _detect_error_patterns(self, error_event: ErrorEvent):\n        \"\"\"Detect recurring error patterns.\"\"\"\n        # Create error signature for pattern detection\n        signature = f\"{error_event.component}_{error_event.exception_type}_{error_event.category.value}\"\n        \n        cutoff_time = datetime.now() - timedelta(seconds=self.pattern_detection_window)\n        \n        # Count similar errors in time window\n        similar_errors = [\n            error for error in self.errors\n            if (\n                error.timestamp >= cutoff_time and\n                f\"{error.component}_{error.exception_type}_{error.category.value}\" == signature\n            )\n        ]\n        \n        # If we have multiple similar errors, create or update pattern\n        if len(similar_errors) >= 3:  # Threshold for pattern detection\n            pattern_id = f\"pattern_{signature}\"\n            \n            if pattern_id in self.error_patterns:\n                # Update existing pattern\n                pattern = self.error_patterns[pattern_id]\n                pattern.last_occurrence = error_event.timestamp\n                pattern.occurrence_count = len(similar_errors)\n                \n                # Update affected components and clients\n                pattern.affected_components = list(set(\n                    pattern.affected_components + [error_event.component]\n                ))\n                if error_event.client_id:\n                    pattern.affected_clients = list(set(\n                        pattern.affected_clients + [error_event.client_id]\n                    ))\n            else:\n                # Create new pattern\n                pattern = ErrorPattern(\n                    pattern_id=pattern_id,\n                    error_signature=signature,\n                    category=error_event.category,\n                    first_occurrence=similar_errors[0].timestamp,\n                    last_occurrence=error_event.timestamp,\n                    occurrence_count=len(similar_errors),\n                    affected_components=[error_event.component],\n                    affected_clients=[error_event.client_id] if error_event.client_id else [],\n                    severity=self._calculate_pattern_severity(similar_errors),\n                    description=f\"Recurring {error_event.exception_type} in {error_event.component}\"\n                )\n                \n                self.error_patterns[pattern_id] = pattern\n                \n                # Notify pattern callbacks\n                for callback in self.pattern_callbacks:\n                    try:\n                        callback(pattern)\n                    except Exception as e:\n                        logger.error(f\"Pattern callback failed: {str(e)}\")\n                \n                logger.warning(f\"Error pattern detected: {pattern_id}\")\n    \n    def _calculate_pattern_severity(self, errors: List[ErrorEvent]) -> ErrorSeverity:\n        \"\"\"Calculate severity for an error pattern based on constituent errors.\"\"\"\n        severity_weights = {\n            ErrorSeverity.LOW: 1,\n            ErrorSeverity.MEDIUM: 2,\n            ErrorSeverity.HIGH: 3,\n            ErrorSeverity.CRITICAL: 4\n        }\n        \n        # Calculate weighted average severity\n        total_weight = sum(severity_weights[error.severity] for error in errors)\n        avg_weight = total_weight / len(errors)\n        \n        # Map back to severity\n        if avg_weight >= 3.5:\n            return ErrorSeverity.CRITICAL\n        elif avg_weight >= 2.5:\n            return ErrorSeverity.HIGH\n        elif avg_weight >= 1.5:\n            return ErrorSeverity.MEDIUM\n        else:\n            return ErrorSeverity.LOW\n    \n    def resolve_error(self, error_id: str, resolution_notes: str = \"\") -> bool:\n        \"\"\"Mark an error as resolved.\"\"\"\n        with self.lock:\n            for error in self.errors:\n                if error.error_id == error_id and not error.resolved:\n                    error.resolved = True\n                    error.resolved_at = datetime.now()\n                    error.resolution_notes = resolution_notes\n                    logger.info(f\"Error resolved: {error_id}\")\n                    return True\n        return False\n    \n    def get_error_summary(self, duration_hours: int = 24) -> Dict[str, Any]:\n        \"\"\"Get summary of errors over specified duration.\"\"\"\n        cutoff_time = datetime.now() - timedelta(hours=duration_hours)\n        \n        with self.lock:\n            recent_errors = [\n                error for error in self.errors\n                if error.timestamp >= cutoff_time\n            ]\n        \n        # Count by category and severity\n        category_counts = defaultdict(int)\n        severity_counts = defaultdict(int)\n        component_counts = defaultdict(int)\n        \n        for error in recent_errors:\n            category_counts[error.category.value] += error.occurrence_count\n            severity_counts[error.severity.value] += error.occurrence_count\n            component_counts[error.component] += error.occurrence_count\n        \n        # Get top errors by occurrence\n        top_errors = sorted(\n            recent_errors,\n            key=lambda x: x.occurrence_count,\n            reverse=True\n        )[:10]\n        \n        return {\n            'duration_hours': duration_hours,\n            'total_errors': len(recent_errors),\n            'total_occurrences': sum(error.occurrence_count for error in recent_errors),\n            'unresolved_errors': len([e for e in recent_errors if not e.resolved]),\n            'category_breakdown': dict(category_counts),\n            'severity_breakdown': dict(severity_counts),\n            'component_breakdown': dict(component_counts),\n            'active_patterns': len(self.error_patterns),\n            'top_errors': [\n                {\n                    'error_id': error.error_id,\n                    'component': error.component,\n                    'category': error.category.value,\n                    'severity': error.severity.value,\n                    'message': error.message,\n                    'occurrence_count': error.occurrence_count,\n                    'timestamp': error.timestamp.isoformat()\n                }\n                for error in top_errors\n            ]\n        }\n    \n    def get_error_patterns(self) -> List[Dict[str, Any]]:\n        \"\"\"Get list of detected error patterns.\"\"\"\n        with self.lock:\n            return [\n                {\n                    'pattern_id': pattern.pattern_id,\n                    'category': pattern.category.value,\n                    'severity': pattern.severity.value,\n                    'occurrence_count': pattern.occurrence_count,\n                    'first_occurrence': pattern.first_occurrence.isoformat(),\n                    'last_occurrence': pattern.last_occurrence.isoformat(),\n                    'affected_components': pattern.affected_components,\n                    'affected_clients': pattern.affected_clients,\n                    'description': pattern.description\n                }\n                for pattern in self.error_patterns.values()\n            ]\n    \n    def add_error_callback(self, callback: Callable[[ErrorEvent], None]):\n        \"\"\"Add callback to be called when errors occur.\"\"\"\n        self.error_callbacks.append(callback)\n        logger.info(\"Added error callback\")\n    \n    def add_pattern_callback(self, callback: Callable[[ErrorPattern], None]):\n        \"\"\"Add callback to be called when patterns are detected.\"\"\"\n        self.pattern_callbacks.append(callback)\n        logger.info(\"Added pattern callback\")\n\n\nclass ErrorHandler:\n    \"\"\"Centralized error handling with automatic categorization and tracking.\"\"\"\n    \n    def __init__(self, component: str, error_tracker: Optional[ErrorTracker] = None):\n        \"\"\"Initialize error handler for a specific component.\"\"\"\n        self.component = component\n        self.error_tracker = error_tracker or ErrorTracker()\n        \n        # Error categorization rules\n        self.categorization_rules = {\n            'ConnectionError': ErrorCategory.NETWORK,\n            'TimeoutError': ErrorCategory.NETWORK,\n            'grpc.RpcError': ErrorCategory.NETWORK,\n            'ValidationError': ErrorCategory.VALIDATION,\n            'ValueError': ErrorCategory.VALIDATION,\n            'PrivacyError': ErrorCategory.PRIVACY,\n            'AggregationError': ErrorCategory.AGGREGATION,\n            'DatabaseError': ErrorCategory.STORAGE,\n            'ConfigurationError': ErrorCategory.CONFIGURATION,\n            'AuthenticationError': ErrorCategory.AUTHENTICATION,\n            'MemoryError': ErrorCategory.SYSTEM,\n            'OSError': ErrorCategory.SYSTEM\n        }\n        \n        logger.info(f\"ErrorHandler initialized for component: {component}\")\n    \n    def handle_error(\n        self,\n        exception: Exception,\n        severity: Optional[ErrorSeverity] = None,\n        context: Optional[Dict[str, Any]] = None,\n        client_id: Optional[str] = None,\n        round_number: Optional[int] = None,\n        reraise: bool = False\n    ) -> str:\n        \"\"\"\n        Handle an error with automatic categorization and tracking.\n        \n        Args:\n            exception: The exception to handle\n            severity: Override severity (auto-detected if not provided)\n            context: Additional context information\n            client_id: Client ID if applicable\n            round_number: Round number if applicable\n            reraise: Whether to reraise the exception after handling\n            \n        Returns:\n            Error ID for tracking\n        \"\"\"\n        # Auto-categorize error\n        category = self._categorize_error(exception)\n        \n        # Auto-determine severity if not provided\n        if severity is None:\n            severity = self._determine_severity(exception, category)\n        \n        # Track the error\n        error_id = self.error_tracker.track_error(\n            component=self.component,\n            exception=exception,\n            category=category,\n            severity=severity,\n            context=context,\n            client_id=client_id,\n            round_number=round_number\n        )\n        \n        # Log the error\n        log_level = {\n            ErrorSeverity.LOW: logging.INFO,\n            ErrorSeverity.MEDIUM: logging.WARNING,\n            ErrorSeverity.HIGH: logging.ERROR,\n            ErrorSeverity.CRITICAL: logging.CRITICAL\n        }[severity]\n        \n        logger.log(\n            log_level,\n            f\"Error handled [{category.value}]: {str(exception)}\",\n            extra={\n                'error_id': error_id,\n                'component': self.component,\n                'client_id': client_id,\n                'round_number': round_number\n            }\n        )\n        \n        if reraise:\n            raise exception\n        \n        return error_id\n    \n    def _categorize_error(self, exception: Exception) -> ErrorCategory:\n        \"\"\"Automatically categorize an error based on its type.\"\"\"\n        exception_name = type(exception).__name__\n        \n        # Check exact matches first\n        if exception_name in self.categorization_rules:\n            return self.categorization_rules[exception_name]\n        \n        # Check for partial matches\n        for pattern, category in self.categorization_rules.items():\n            if pattern.lower() in exception_name.lower():\n                return category\n        \n        # Check exception message for clues\n        message = str(exception).lower()\n        if any(word in message for word in ['network', 'connection', 'timeout']):\n            return ErrorCategory.NETWORK\n        elif any(word in message for word in ['privacy', 'differential', 'epsilon']):\n            return ErrorCategory.PRIVACY\n        elif any(word in message for word in ['validation', 'invalid', 'format']):\n            return ErrorCategory.VALIDATION\n        elif any(word in message for word in ['aggregation', 'fedavg']):\n            return ErrorCategory.AGGREGATION\n        elif any(word in message for word in ['database', 'storage', 'file']):\n            return ErrorCategory.STORAGE\n        \n        return ErrorCategory.UNKNOWN\n    \n    def _determine_severity(self, exception: Exception, category: ErrorCategory) -> ErrorSeverity:\n        \"\"\"Automatically determine error severity.\"\"\"\n        exception_name = type(exception).__name__\n        \n        # Critical errors\n        if exception_name in ['MemoryError', 'SystemExit', 'KeyboardInterrupt']:\n            return ErrorSeverity.CRITICAL\n        \n        # High severity errors\n        if exception_name in ['ConnectionError', 'DatabaseError', 'AuthenticationError']:\n            return ErrorSeverity.HIGH\n        \n        # Category-based severity\n        if category == ErrorCategory.PRIVACY:\n            return ErrorSeverity.HIGH  # Privacy errors are always high severity\n        elif category == ErrorCategory.NETWORK:\n            return ErrorSeverity.MEDIUM\n        elif category == ErrorCategory.VALIDATION:\n            return ErrorSeverity.LOW\n        \n        return ErrorSeverity.MEDIUM\n    \n    def context_manager(self, **context_kwargs):\n        \"\"\"Context manager for automatic error handling.\"\"\"\n        return ErrorHandlerContext(self, context_kwargs)\n\n\nclass ErrorHandlerContext:\n    \"\"\"Context manager for automatic error handling.\"\"\"\n    \n    def __init__(self, error_handler: ErrorHandler, context: Dict[str, Any]):\n        \"\"\"Initialize context manager.\"\"\"\n        self.error_handler = error_handler\n        self.context = context\n    \n    def __enter__(self):\n        \"\"\"Enter context.\"\"\"\n        return self\n    \n    def __exit__(self, exc_type, exc_val, exc_tb):\n        \"\"\"Exit context and handle any exceptions.\"\"\"\n        if exc_type is not None:\n            self.error_handler.handle_error(\n                exception=exc_val,\n                context=self.context\n            )\n            return True  # Suppress the exception\n        return False\n\n\n# Global error tracker instance\n_global_error_tracker = None\n\n\ndef get_global_error_tracker() -> ErrorTracker:\n    \"\"\"Get or create global error tracker instance.\"\"\"\n    global _global_error_tracker\n    if _global_error_tracker is None:\n        _global_error_tracker = ErrorTracker()\n    return _global_error_tracker\n\n\ndef create_error_handler(component: str) -> ErrorHandler:\n    \"\"\"Create error handler for a component using global tracker.\"\"\"\n    return ErrorHandler(component, get_global_error_tracker())\n\n\n# Example usage\nif __name__ == \"__main__\":\n    # Test error tracking\n    error_handler = create_error_handler(\"test_component\")\n    \n    # Test different types of errors\n    try:\n        raise ConnectionError(\"Failed to connect to server\")\n    except Exception as e:\n        error_handler.handle_error(e, client_id=\"test_client\")\n    \n    try:\n        raise ValueError(\"Invalid model parameters\")\n    except Exception as e:\n        error_handler.handle_error(e, round_number=5)\n    \n    # Test context manager\n    with error_handler.context_manager(client_id=\"test_client\", round_number=1):\n        raise RuntimeError(\"Something went wrong\")\n    \n    # Get error summary\n    tracker = get_global_error_tracker()\n    summary = tracker.get_error_summary()\n    print(json.dumps(summary, indent=2))